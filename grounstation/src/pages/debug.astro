---
import { CONFIG } from '../shared/config/app-config.js';

const defaultHost = CONFIG.rtmp.defaultHost;
const defaultStreamPath = `${CONFIG.rtmp.defaultApp}/${CONFIG.rtmp.defaultStream}`;
const webrtcPort = CONFIG.webrtc.defaultPort;
const connectionTimeout = CONFIG.connection.timeoutMs;
const apiEndpoints = CONFIG.connection.testEndpoints;
const defaultRtmpPort = CONFIG.rtmp.defaultPort;
---

<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTCè§†é¢‘æ’­æ”¾è°ƒè¯•é¡µé¢</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background: #f5f5f5;
      }

      .debug-container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .video-container {
        width: 100%;
        height: 400px;
        background: #000;
        border-radius: 8px;
        margin: 20px 0;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #ccc;
        font-size: 18px;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 8px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin: 20px 0;
      }

      button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }

      .play-btn {
        background: #4caf50;
        color: white;
      }

      .stop-btn {
        background: #f44336;
        color: white;
      }

      .debug-btn {
        background: #2196f3;
        color: white;
      }

      .logs {
        background: #1e1e1e;
        color: #fff;
        padding: 15px;
        border-radius: 5px;
        height: 300px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
        line-height: 1.4;
      }

      .log-success {
        color: #4caf50;
      }

      .log-error {
        color: #f44336;
      }

      .log-warning {
        color: #ff9800;
      }

      .log-info {
        color: #2196f3;
      }

      .config {
        margin: 20px 0;
      }

      .config input {
        width: 300px;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin: 0 10px;
      }

      h1 {
        color: #333;
      }

      h2 {
        color: #666;
        margin-top: 30px;
      }

      .status {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        margin-left: 10px;
      }

      .status-idle {
        background: #eee;
        color: #666;
      }

      .status-connecting {
        background: #fff3cd;
        color: #856404;
      }

      .status-connected {
        background: #d4edda;
        color: #155724;
      }

      .status-failed {
        background: #f8d7da;
        color: #721c24;
      }
    </style>
  </head>
  <body>
    <div class="debug-container">
      <h1>ğŸ” WebRTCè§†é¢‘æ’­æ”¾è°ƒè¯•å·¥å…·</h1>

      <div class="config">
        <label>MediaMTXä¸»æœº:</label>
        <input type="text" id="host" value={defaultHost} placeholder={defaultHost} />

        <label>æµè·¯å¾„:</label>
        <input type="text" id="streamPath" value={defaultStreamPath} placeholder={defaultStreamPath} />

        <span class="status status-idle" id="connection-status">å¾…è¿æ¥</span>
      </div>

      <div class="controls">
        <button class="play-btn" onclick="startPlay()">â–¶ï¸ å¼€å§‹æ’­æ”¾</button>
        <button class="stop-btn" onclick="stopPlay()">â¹ï¸ åœæ­¢æ’­æ”¾</button>
        <button class="debug-btn" onclick="debugVideo()">ğŸ” è°ƒè¯•ä¿¡æ¯</button>
        <button class="debug-btn" onclick="testConnection()">ğŸ”— æµ‹è¯•è¿æ¥</button>
        <button class="debug-btn" onclick="clearLogs()">ğŸ§¹ æ¸…é™¤æ—¥å¿—</button>
      </div>

      <div class="video-container" id="video-container"> ğŸ¥ ç‚¹å‡»å¼€å§‹æ’­æ”¾ä»¥æ˜¾ç¤ºè§†é¢‘æµ </div>

      <h2>ğŸ“‹ å®æ—¶æ—¥å¿—</h2>
      <div class="logs" id="logs"></div>
    </div>

    <script type="module" is:inline>
      const APP_DEFAULTS = JSON.parse(
        decodeURIComponent("{encodeURIComponent(JSON.stringify(defaultConfig))}")
      );

      let pc = null;
      let videoElement = null;
      let isPlaying = false;

      function log(message, type = 'info') {
        const logs = document.getElementById('logs');
        const time = new Date().toLocaleTimeString();
        const logLine = document.createElement('div');
        logLine.className = `log-${type}`;
        logLine.textContent = `[${time}] ${message}`;
        logs.appendChild(logLine);
        logs.scrollTop = logs.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      function clearLogs() {
        document.getElementById('logs').innerHTML = '';
      }

      function updateStatus(status, text) {
        const statusEl = document.getElementById('connection-status');
        statusEl.className = `status status-${status}`;
        statusEl.textContent = text;
      }

      async function testConnection() {
        const host = document.getElementById('host').value || APP_DEFAULTS.host;
        log(`æµ‹è¯•MediaMTXè¿æ¥: ${host}`);

        const testUrls = [
          `http://${host}:${APP_DEFAULTS.webrtcPort}/`,
          ...APP_DEFAULTS.apiEndpoints.map((endpoint) => `http://${host}${endpoint}`)
        ];

        for (const url of testUrls) {
          try {
            await fetch(url, {
              method: 'GET',
              mode: 'no-cors',
              signal: AbortSignal.timeout(APP_DEFAULTS.timeoutMs)
            });
            log(`âœ… ${url} å¯è®¿é—®`, 'success');
            return;
          } catch (error) {
            log(`âŒ ${url} ä¸å¯è®¿é—®: ${error.message}`, 'warning');
          }
        }

        log('æ‰€æœ‰æµ‹è¯•ç«¯ç‚¹å‡ä¸å¯è®¿é—®', 'error');
      }

      async function startPlay() {
        if (isPlaying) {
          log('å·²ç»åœ¨æ’­æ”¾ä¸­', 'warning');
          return;
        }

        const host = document.getElementById('host').value || APP_DEFAULTS.host;
        const streamPath = document.getElementById('streamPath').value || APP_DEFAULTS.streamPath;
        const rtmpUrl = `rtmp://${host}:${APP_DEFAULTS.rtmpPort}/${streamPath}`;
        const whepUrl = `http://${host}:${APP_DEFAULTS.webrtcPort}/${streamPath}/whep`;

        log(`ğŸš€ å¼€å§‹æ’­æ”¾: ${rtmpUrl}`);
        log(`WHEPç«¯ç‚¹: ${whepUrl}`);

        updateStatus('connecting', 'è¿æ¥ä¸­...');

        try {
          createVideoElement();
          await createWebRTCConnection(whepUrl);

          log('âœ… æ’­æ”¾å¯åŠ¨å®Œæˆ', 'success');
        } catch (error) {
          log(`âŒ æ’­æ”¾å¤±è´¥: ${error.message}`, 'error');
          updateStatus('failed', 'è¿æ¥å¤±è´¥');
        }
      }

      function createVideoElement() {
        const container = document.getElementById('video-container');
        container.innerHTML = '';

        videoElement = document.createElement('video');
        videoElement.controls = true;
        videoElement.autoplay = true;
        videoElement.muted = true;
        videoElement.playsInline = true;

        videoElement.addEventListener('loadedmetadata', () => {
          log(`ğŸ“ è§†é¢‘å°ºå¯¸: ${videoElement.videoWidth}x${videoElement.videoHeight}`, 'info');
        });

        videoElement.addEventListener('playing', () => {
          log('â–¶ï¸ è§†é¢‘å¼€å§‹æ’­æ”¾', 'success');
          isPlaying = true;
          updateStatus('connected', 'æ’­æ”¾ä¸­');
        });

        videoElement.addEventListener('pause', () => {
          log('â¸ï¸ è§†é¢‘å·²æš‚åœ', 'info');
        });

        videoElement.addEventListener('error', (e) => {
          log(`âŒ è§†é¢‘é”™è¯¯: ${e.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
          log(`é”™è¯¯ä»£ç : ${videoElement.error?.code || 'N/A'}`, 'error');
        });

        container.appendChild(videoElement);
        log('âœ… Videoå…ƒç´ åˆ›å»ºå®Œæˆ', 'success');
      }

      async function createWebRTCConnection(whepUrl) {
        pc = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        pc.ontrack = (event) => {
          log('ğŸ¬ æ¥æ”¶åˆ°WebRTCæµ', 'success');
          log(`æµæ•°é‡: ${event.streams.length}`, 'info');

          const stream = event.streams[0];
          log(`è½¨é“æ•°é‡: ${stream.getTracks().length}`, 'info');

          stream.getTracks().forEach((track, index) => {
            log(`è½¨é“ ${index}: ${track.kind} - ${track.readyState}`, 'info');
          });

          videoElement.srcObject = stream;

          videoElement
            .play()
            .then(() => {
              log('âœ… è§†é¢‘æ’­æ”¾æˆåŠŸ', 'success');
            })
            .catch((error) => {
              log(`âŒ è§†é¢‘æ’­æ”¾å¤±è´¥: ${error.message}`, 'error');
            });
        };

        pc.oniceconnectionstatechange = () => {
          log(`ğŸ”— ICEè¿æ¥çŠ¶æ€: ${pc.iceConnectionState}`, 'info');

          switch (pc.iceConnectionState) {
            case 'connected':
              updateStatus('connected', 'å·²è¿æ¥');
              break;
            case 'failed':
              updateStatus('failed', 'è¿æ¥å¤±è´¥');
              log('âŒ WebRTCè¿æ¥å¤±è´¥', 'error');
              break;
            case 'disconnected':
              updateStatus('idle', 'å·²æ–­å¼€');
              break;
          }
        };

        pc.onicegatheringstatechange = () => {
          log(`ğŸ§Š ICEæ”¶é›†çŠ¶æ€: ${pc.iceGatheringState}`, 'info');
        };

        const offer = await pc.createOffer({
          offerToReceiveVideo: true,
          offerToReceiveAudio: true
        });

        await pc.setLocalDescription(offer);
        log('ğŸ“¤ æœ¬åœ°SDPå·²è®¾ç½®', 'info');

        const response = await fetch(whepUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp' },
          body: offer.sdp
        });

        if (!response.ok) {
          throw new Error(`WHEPè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
        }

        const answerSdp = await response.text();
        await pc.setRemoteDescription({
          type: 'answer',
          sdp: answerSdp
        });

        log('ğŸ“¥ è¿œç¨‹SDPå·²è®¾ç½®', 'success');
        log('ğŸ¤ WebRTCæ¡æ‰‹å®Œæˆ', 'success');
      }

      function stopPlay() {
        if (pc) {
          pc.close();
          pc = null;
          log('ğŸ”Œ WebRTCè¿æ¥å·²å…³é—­', 'info');
        }

        if (videoElement) {
          videoElement.pause();
          videoElement.srcObject = null;
          videoElement = null;
          log('â¹ï¸ è§†é¢‘æ’­æ”¾å·²åœæ­¢', 'info');
        }

        const container = document.getElementById('video-container');
        container.innerHTML = 'ğŸ¥ ç‚¹å‡»å¼€å§‹æ’­æ”¾ä»¥æ˜¾ç¤ºè§†é¢‘æµ';

        isPlaying = false;
        updateStatus('idle', 'å¾…è¿æ¥');

        log('âœ… åœæ­¢å®Œæˆ', 'success');
      }

      function debugVideo() {
        log('=== ğŸ” è°ƒè¯•ä¿¡æ¯ ===', 'info');

        if (videoElement) {
          log(`Videoå…ƒç´ å­˜åœ¨: ${videoElement ? 'æ˜¯' : 'å¦'}`, 'info');
          log(`srcObjectè®¾ç½®: ${videoElement.srcObject ? 'æ˜¯' : 'å¦'}`, 'info');
          log(`readyState: ${videoElement.readyState}`, 'info');
          log(`paused: ${videoElement.paused}`, 'info');
          log(`currentTime: ${videoElement.currentTime}`, 'info');
          log(`duration: ${videoElement.duration}`, 'info');
          log(`videoWidth: ${videoElement.videoWidth}`, 'info');
          log(`videoHeight: ${videoElement.videoHeight}`, 'info');
          log(`volume: ${videoElement.volume}`, 'info');
          log(`muted: ${videoElement.muted}`, 'info');

          if (videoElement.srcObject) {
            const stream = videoElement.srcObject;
            log(`Stream active: ${stream.active}`, 'info');
            log(`Stream id: ${stream.id}`, 'info');

            stream.getTracks().forEach((track, index) => {
              log(
                `Track ${index}: ${track.kind}, enabled: ${track.enabled}, muted: ${track.muted}, readyState: ${track.readyState}`,
                'info'
              );
            });
          }
        } else {
          log('Videoå…ƒç´ ä¸å­˜åœ¨', 'warning');
        }

        if (pc) {
          log(`WebRTCè¿æ¥çŠ¶æ€: ${pc.connectionState}`, 'info');
          log(`ICEè¿æ¥çŠ¶æ€: ${pc.iceConnectionState}`, 'info');
          log(`ICEæ”¶é›†çŠ¶æ€: ${pc.iceGatheringState}`, 'info');
          log(`ä¿¡ä»¤çŠ¶æ€: ${pc.signalingState}`, 'info');
        } else {
          log('RTCPeerConnectionä¸å­˜åœ¨', 'warning');
        }
      }

      window.startPlay = startPlay;
      window.stopPlay = stopPlay;
      window.debugVideo = debugVideo;
      window.testConnection = testConnection;
      window.clearLogs = clearLogs;
    </script>
  </body>
</html>
