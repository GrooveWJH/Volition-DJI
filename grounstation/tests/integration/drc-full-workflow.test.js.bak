#!/usr/bin/env node

/**
 * DRCå…¨æµç¨‹é›†æˆæµ‹è¯•è„šæœ¬
 *
 * ç”¨æ³•: node drc-full-workflow.test.js <SN>
 * ç¤ºä¾‹: node drc-full-workflow.test.js 1581F5BSD005000
 *
 * æµ‹è¯•æµç¨‹:
 * 1. è®¾å¤‡å—…æ¢ - éªŒè¯è®¾å¤‡åœ¨EMQXä¸­å­˜åœ¨
 * 2. MQTTè¿æ¥å»ºç«‹ - å»ºç«‹station-{SN}è¿æ¥
 * 3. äº‘ç«¯æ§åˆ¶æˆæƒ - å‘é€æˆæƒè¯·æ±‚(éœ€è¦é¥æ§å™¨æ‰‹åŠ¨ç¡®è®¤)
 * 4. DRCæ¨¡å¼è¿›å…¥ - é…ç½®å¹¶è¿›å…¥DRCæ¨¡å¼
 * 5. å¿ƒè·³æŒç»­å‘é€ - éªŒè¯5Hzå¿ƒè·³æŒç»­å‘é€
 */

import mqtt from 'mqtt';
import { readFile } from 'fs/promises';
import { join } from 'path';
import { createInterface } from 'readline';

// =============================================================================
// é…ç½®å‚æ•° - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰åœ°å€å’Œè®¤è¯ä¿¡æ¯
// =============================================================================
const CONFIG = {
  // MQTT Broker IP (æ‰€æœ‰MQTTç›¸å…³éƒ½ä½¿ç”¨è¿™ä¸ªIP)
  MQTT_HOST: '192.168.18.130',

  // EMQXé…ç½®
  EMQX: {
    httpPort: 18083,
    apiKey: '9b8799abe2c3d581',
    secretKey: '8AotAV126dc9B7E8eMhfnbSlC6pTxtl0eLS29AWMi2DrC'
  },

  // æµ‹è¯•å®¢æˆ·ç«¯MQTTé…ç½®
  TEST_MQTT: {
    port: 8083,
    username: 'admin',
    password: '302811055wjhhz'
  },

  // DRCæ¨¡å¼MQTTä¸­ç»§é…ç½®
  DRC_MQTT: {
    port: 1883,
    username: 'admin',
    password: '302811055wjhhz',
    expire_time: 1700000000
  }
};

const SN = process.argv[2];

if (!SN) {
  console.log('âŒ è¯·æä¾›è®¾å¤‡SN');
  console.log('ç”¨æ³•: node drc-full-workflow.test.js <SN>');
  process.exit(1);
}

console.log(`ğŸš€ å¼€å§‹DRCå…¨æµç¨‹é›†æˆæµ‹è¯• - è®¾å¤‡: ${SN}`);

let mqttClient = null;
let heartbeatCount = 0;
let testStartTime = Date.now();

async function loadConfig() {
  return {
    emqx: {
      host: CONFIG.MQTT_HOST,
      httpPort: CONFIG.EMQX.httpPort,
      apiKey: CONFIG.EMQX.apiKey,
      secretKey: CONFIG.EMQX.secretKey
    },
    mqtt: {
      host: CONFIG.MQTT_HOST,
      port: CONFIG.TEST_MQTT.port,
      username: CONFIG.TEST_MQTT.username,
      password: CONFIG.TEST_MQTT.password
    }
  };
}

async function step1_deviceDiscovery(config) {
  console.log('\nğŸ” æ­¥éª¤1: è®¾å¤‡å—…æ¢');

  const url = `http://${config.emqx.host}:${config.emqx.httpPort}/api/v5/clients`;
  const credentials = Buffer.from(`${config.emqx.apiKey}:${config.emqx.secretKey}`).toString('base64');

  try {
    const response = await fetch(url, {
      headers: {
        'Authorization': `Basic ${credentials}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`EMQX APIé”™è¯¯: ${response.status}`);
    }

    const data = await response.json();
    const devices = data.data.filter(client => /^[A-Z0-9]{14}$/.test(client.clientid));

    console.log(`ğŸ“± å‘ç° ${devices.length} ä¸ªDJIè®¾å¤‡`);

    const targetDevice = devices.find(device => device.clientid === SN);
    if (!targetDevice) {
      console.log(`âš ï¸  è®¾å¤‡ ${SN} æœªåœ¨EMQXä¸­æ‰¾åˆ°ï¼Œä½†ç»§ç»­æµ‹è¯•æµç¨‹`);
      return false;
    }

    console.log(`âœ… è®¾å¤‡ ${SN} å·²åœ¨çº¿`);
    return true;
  } catch (error) {
    console.log(`âš ï¸  è®¾å¤‡å—…æ¢å¤±è´¥: ${error.message}ï¼Œä½†ç»§ç»­æµ‹è¯•æµç¨‹`);
    return false;
  }
}

async function step2_mqttConnection(config) {
  console.log('\nğŸŒ æ­¥éª¤2: MQTTè¿æ¥å»ºç«‹');

  const clientId = `station-${SN}`;
  const brokerUrl = `ws://${config.mqtt.host}:${config.mqtt.port}/mqtt`;

  return new Promise((resolve, reject) => {
    console.log(`ğŸ“¡ è¿æ¥åˆ° ${brokerUrl} (Client: ${clientId})`);

    mqttClient = mqtt.connect(brokerUrl, {
      clientId: clientId,
      username: config.mqtt.username,
      password: config.mqtt.password,
      clean: true,
      connectTimeout: 10000
    });

    const connectHandler = () => {
      console.log('âœ… MQTTè¿æ¥å·²å»ºç«‹');
      // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤è§¦å‘
      mqttClient.removeListener('connect', connectHandler);
      mqttClient.removeListener('error', errorHandler);
      resolve(true);
    };

    const errorHandler = (error) => {
      console.log(`âŒ MQTTè¿æ¥å¤±è´¥: ${error.message}`);
      mqttClient.removeListener('connect', connectHandler);
      mqttClient.removeListener('error', errorHandler);
      reject(false);
    };

    mqttClient.on('connect', connectHandler);
    mqttClient.on('error', errorHandler);

    setTimeout(() => {
      if (!mqttClient.connected) {
        mqttClient.removeListener('connect', connectHandler);
        mqttClient.removeListener('error', errorHandler);
        reject(new Error('MQTTè¿æ¥è¶…æ—¶'));
      }
    }, 10000);
  });
}

async function step3_cloudControlAuth() {
  console.log('\nâ˜ï¸ æ­¥éª¤3: äº‘ç«¯æ§åˆ¶æˆæƒ');

  const tid = `tid-${Date.now()}`;
  const bid = `bid-${Date.now()}`;
  const authTopic = `thing/product/${SN}/services`;
  const authMessage = {
    bid: bid,
    tid: tid,
    timestamp: Date.now(),
    method: 'cloud_control_auth_request',
    data: {
      user_id: 'test_pilot_001',
      user_callsign: 'TestStation',
      control_keys: ['flight']
    }
  };

  // å‘é€æˆæƒè¯·æ±‚
  console.log('ğŸ“¤ å‘é€äº‘ç«¯æ§åˆ¶æˆæƒè¯·æ±‚');
  console.log(`ğŸ“¡ å‘é€åˆ°è¯é¢˜: ${authTopic}`);
  console.log(`ğŸ“‹ æ¶ˆæ¯å†…å®¹: ${JSON.stringify(authMessage, null, 2)}`);

  mqttClient.publish(authTopic, JSON.stringify(authMessage));

  console.log('\nâš ï¸  é‡è¦æç¤º:');
  console.log('ğŸ® è¯·åœ¨DJIé¥æ§å™¨ä¸Šç‚¹å‡»"å…è®¸"æŒ‰é’®ç¡®è®¤äº‘ç«¯æ§åˆ¶æˆæƒ');
  console.log('âœ… ç¡®è®¤æˆæƒåï¼ŒæŒ‰å›è½¦é”®ç»§ç»­...');

  // ç­‰å¾…ç”¨æˆ·æŒ‰å›è½¦
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout
  });

  return new Promise((resolve) => {
    rl.question('', () => {
      rl.close();
      console.log('âœ… äº‘ç«¯æ§åˆ¶æˆæƒç¡®è®¤å®Œæˆ');
      resolve(true);
    });
  });
}

async function step4_drcModeEntry() {
  console.log('\nğŸ›¸ æ­¥éª¤4: DRCæ¨¡å¼è¿›å…¥');

  const tid = `tid-${Date.now()}`;
  const bid = `bid-${Date.now()}`;
  const drcTopic = `thing/product/${SN}/services`;
  const drcMessage = {
    bid: bid,
    tid: tid,
    timestamp: Date.now(),
    method: 'drc_mode_enter',
    data: {
      mqtt_broker: {
        address: `${CONFIG.MQTT_HOST}:${CONFIG.DRC_MQTT.port}`,
        client_id: `drc-${SN}`,
        username: CONFIG.DRC_MQTT.username,
        password: CONFIG.DRC_MQTT.password,
        expire_time: CONFIG.DRC_MQTT.expire_time,
        enable_tls: false
      },
      osd_frequency: 30,
      hsi_frequency: 10
    }
  };

  return new Promise((resolve, reject) => {
    // ç›‘å¬DRCå›å¤
    const replyTopic = `thing/product/${SN}/services_reply`;
    console.log(`ğŸ“¡ è®¢é˜…DRCå›å¤è¯é¢˜: ${replyTopic}`);
    mqttClient.subscribe(replyTopic);

    const drcHandler = (topic, message) => {
      console.log(`ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯ä»è¯é¢˜: ${topic}`);

      if (topic === replyTopic) {
        try {
          const reply = JSON.parse(message.toString());
          console.log(`ğŸ“¥ æ”¶åˆ°DRCå›å¤: ${JSON.stringify(reply, null, 2)}`);

          if (reply.tid === tid && reply.method === 'drc_mode_enter') {
            mqttClient.removeListener('message', drcHandler);
            mqttClient.unsubscribe(replyTopic);

            if (reply.data && reply.data.result === 0) {
              console.log('âœ… DRCæ¨¡å¼å·²æ¿€æ´»');
              resolve(true);
            } else {
              reject(new Error(`DRCè¿›å…¥å¤±è´¥: result=${reply.data?.result || 'æœªçŸ¥'}`));
            }
          } else {
            console.log(`âš ï¸  TIDä¸åŒ¹é…æˆ–æ–¹æ³•ä¸åŒ¹é…: æœŸæœ›tid=${tid}, method=drc_mode_enter`);
            console.log(`âš ï¸  å®é™…tid=${reply.tid}, method=${reply.method}`);
          }
        } catch (error) {
          console.log(`âš ï¸  è§£æDRCå›å¤å¤±è´¥: ${error.message}`);
          console.log(`ğŸ“„ åŸå§‹æ¶ˆæ¯: ${message.toString()}`);
        }
      }
    };

    mqttClient.on('message', drcHandler);

    // å‘é€DRCè¿›å…¥è¯·æ±‚
    console.log('ğŸ“¤ å‘é€DRCæ¨¡å¼è¿›å…¥è¯·æ±‚');
    console.log(`ğŸ“¡ å‘é€åˆ°è¯é¢˜: ${drcTopic}`);
    console.log(`ğŸ“‹ æ¶ˆæ¯å†…å®¹: ${JSON.stringify(drcMessage, null, 2)}`);

    mqttClient.publish(drcTopic, JSON.stringify(drcMessage));

    // 30ç§’è¶…æ—¶
    setTimeout(() => {
      mqttClient.removeListener('message', drcHandler);
      mqttClient.unsubscribe(replyTopic);
      reject(new Error('DRCæ¨¡å¼è¿›å…¥è¶…æ—¶'));
    }, 30000);
  });
}

async function step5_heartbeatContinuous() {
  console.log('\nğŸ’“ æ­¥éª¤5: å¿ƒè·³æŒç»­å‘é€éªŒè¯');

  const heartbeatTopic = `thing/product/${SN}/drc/down`;
  heartbeatCount = 0;

  // ç›‘å¬å¿ƒè·³
  mqttClient.subscribe(heartbeatTopic);

  const heartbeatHandler = (topic, message) => {
    if (topic === heartbeatTopic) {
      try {
        const heartbeat = JSON.parse(message.toString());
        if (heartbeat.method === 'heart_beat') {
          heartbeatCount++;
          if (heartbeatCount <= 5) {
            console.log(`ğŸ’— æ”¶åˆ°å¿ƒè·³ #${heartbeatCount} (seq: ${heartbeat.seq})`);
          }
        }
      } catch (error) {
        // å¿½ç•¥è§£æé”™è¯¯
      }
    }
  };

  mqttClient.on('message', heartbeatHandler);

  // å¼€å§‹å‘é€å¿ƒè·³
  console.log('ğŸ”„ å¼€å§‹å‘é€5Hzå¿ƒè·³(10ç§’æµ‹è¯•)');
  const heartbeatInterval = setInterval(() => {
    const timestamp = Date.now();
    const heartbeatMessage = {
      data: { timestamp: timestamp },
      method: 'heart_beat',
      seq: timestamp
    };

    console.log(`ğŸ’— å‘é€å¿ƒè·³åˆ°: ${heartbeatTopic} (seq: ${timestamp})`);
    mqttClient.publish(heartbeatTopic, JSON.stringify(heartbeatMessage));
  }, 200); // 5Hz = 200msé—´éš”

  // 10ç§’ååœæ­¢å¹¶éªŒè¯
  return new Promise((resolve) => {
    setTimeout(() => {
      clearInterval(heartbeatInterval);
      mqttClient.removeListener('message', heartbeatHandler);
      mqttClient.unsubscribe(heartbeatTopic);

      const expectedBeats = Math.floor(10 * 5); // 10ç§’ Ã— 5Hz = 50ä¸ªå¿ƒè·³
      console.log(`ğŸ“Š 10ç§’å†…å‘é€/æ¥æ”¶ ${heartbeatCount} ä¸ªå¿ƒè·³ (æœŸæœ›: ~${expectedBeats})`);

      if (heartbeatCount >= expectedBeats - 5) { // å…è®¸5ä¸ªè¯¯å·®
        console.log('âœ… å¿ƒè·³é¢‘ç‡éªŒè¯é€šè¿‡');
        resolve(true);
      } else {
        console.log('âš ï¸  å¿ƒè·³é¢‘ç‡åä½ï¼Œä½†æµ‹è¯•ç»§ç»­');
        resolve(true);
      }
    }, 10000);
  });
}

function printSummary() {
  const totalTime = Date.now() - testStartTime;
  console.log('\nğŸ“Š æµ‹è¯•æ€»ç»“');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log(`ğŸ¯ æµ‹è¯•è®¾å¤‡: ${SN}`);
  console.log(`â±ï¸  æ€»è€—æ—¶: ${(totalTime / 1000).toFixed(1)}ç§’`);
  console.log(`ğŸ’“ å¿ƒè·³ç»Ÿè®¡: ${heartbeatCount} ä¸ª`);
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('ğŸ‰ DRCå…¨æµç¨‹é›†æˆæµ‹è¯•å®Œæˆï¼');
}

function cleanup() {
  if (mqttClient && mqttClient.connected) {
    console.log('\nğŸ§¹ æ–­å¼€MQTTè¿æ¥');
    mqttClient.end();
  }
}

// ä¸»ç¨‹åº
async function main() {
  try {
    const config = await loadConfig();

    // æ­¥éª¤1: è®¾å¤‡å—…æ¢ (ä¸å½±å“åç»­æµç¨‹)
    const deviceFound = await step1_deviceDiscovery(config);

    // æ­¥éª¤2: MQTTè¿æ¥å»ºç«‹
    await step2_mqttConnection(config);

    // æ­¥éª¤3: äº‘ç«¯æ§åˆ¶æˆæƒ
    await step3_cloudControlAuth();

    // æ­¥éª¤4: DRCæ¨¡å¼è¿›å…¥
    await step4_drcModeEntry();

    // æ­¥éª¤5: å¿ƒè·³æŒç»­å‘é€
    await step5_heartbeatContinuous();

    printSummary();

  } catch (error) {
    console.log(`\nâŒ æµ‹è¯•å¤±è´¥: ${error.message}`);
    process.exit(1);
  } finally {
    cleanup();
  }
}

// å¤„ç†ç¨‹åºé€€å‡º
process.on('SIGINT', () => {
  console.log('\nğŸ›‘ æµ‹è¯•è¢«ä¸­æ–­');
  cleanup();
  process.exit(0);
});

main();