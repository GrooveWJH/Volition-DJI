<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>DRC 虚拟摇杆</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <style>
        :root {
            color-scheme: light;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }
        body {
            margin: 0;
            padding: 0;
            background: #0e1117;
            color: #f5f6f7;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        header {
            padding: 1.5rem 1rem 1rem;
            text-align: center;
            background: linear-gradient(135deg, #13294b 0%, #0e7afe 100%);
        }
        header h1 {
            margin: 0;
            font-size: 1.6rem;
            font-weight: 600;
        }
        main {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 0.75rem 1rem;
            background: rgba(19, 41, 75, 0.75);
            border-radius: 12px;
            padding: 1rem;
        }
        label {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            font-size: 0.9rem;
        }
        input,
        select {
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.6rem 0.75rem;
            font-size: 1rem;
            background: rgba(14, 26, 45, 0.9);
            color: inherit;
        }
        input:focus {
            outline: 2px solid #0e7afe;
        }
        .actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        button {
            border: none;
            border-radius: 999px;
            padding: 0.6rem 1.4rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            background: #0e7afe;
            color: inherit;
        }
        button.secondary {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.95rem;
        }
        .status-dot {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            background: #f5a623;
            box-shadow: 0 0 0.3rem rgba(245, 166, 35, 0.8);
        }
        .status-dot.connected {
            background: #34c759;
            box-shadow: 0 0 0.6rem rgba(52, 199, 89, 0.8);
        }
        .status-dot.error {
            background: #ff453a;
            box-shadow: 0 0 0.6rem rgba(255, 69, 58, 0.8);
        }
        .joysticks {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1rem;
        }
        .stick-card {
            position: relative;
            background: rgba(19, 41, 75, 0.7);
            border-radius: 16px;
            padding: 1rem;
            min-height: 320px;
        }
        .stick-card h2 {
            margin: 0 0 0.5rem;
            font-size: 1.15rem;
        }
        .stick-area {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 12px;
            background:
                linear-gradient(to right, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.02)),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.02)),
                rgba(14, 26, 45, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            touch-action: none;
            box-shadow: inset 0 0 0 1px rgba(14, 122, 254, 0.25);
        }
        .stick-area::before {
            content: "";
            position: absolute;
            inset: 6%;
            border: 1px solid rgba(14, 122, 254, 0.25);
            pointer-events: none;
        }
        .stick-area::after {
            content: "";
            position: absolute;
            inset: 0;
            background:
                linear-gradient(
                    to right,
                    transparent calc(50% - 0.5px),
                    rgba(255, 255, 255, 0.22) 50%,
                    transparent calc(50% + 0.5px)
                ),
                linear-gradient(
                    to bottom,
                    transparent calc(50% - 0.5px),
                    rgba(255, 255, 255, 0.22) 50%,
                    transparent calc(50% + 0.5px)
                );
            pointer-events: none;
        }
        .stick-indicator {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 42px;
            height: 42px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(14, 122, 254, 0.8), rgba(94, 167, 255, 0.9));
            border: 2px solid rgba(255, 255, 255, 0.65);
            box-shadow: 0 6px 14px rgba(14, 122, 254, 0.45);
            transform: translate(-50%, -50%);
            transition: transform 50ms ease;
            pointer-events: none;
            z-index: 5;
        }
        .stick-channel {
            margin-top: 0.75rem;
            font-size: 0.95rem;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.3rem 1rem;
        }
        .stick-channel span {
            display: inline-flex;
            justify-content: space-between;
            background: rgba(14, 26, 45, 0.6);
            border-radius: 8px;
            padding: 0.35rem 0.6rem;
        }
        .payload {
            background: rgba(19, 41, 75, 0.55);
            border-radius: 12px;
            padding: 1rem;
            font-family: "SFMono-Regular", Consolas, ui-monospace, Menlo, Monaco, "Courier New", monospace;
            font-size: 0.88rem;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .warning {
            font-size: 0.9rem;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.7);
        }
        @media (orientation: landscape) {
            main {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>DRC 虚拟摇杆（MQTT）</h1>
    </header>
    <main>
        <form id="connection-form">
            <label>
                Broker 地址
                <input type="text" name="host" required value="192.168.31.241" autocomplete="off">
            </label>
            <label>
                端口
                <input type="number" name="port" required value="8083" min="1" max="65535">
            </label>
            <label>
                路径
                <input type="text" name="path" value="/mqtt">
            </label>
            <label>
                Client ID
                <input type="text" name="clientId" placeholder="drc-joystick-..." autocomplete="off">
            </label>
            <label>
                用户名
                <input type="text" name="username" value="admin" autocomplete="username">
            </label>
            <label>
                密码
                <input type="password" name="password" value="302811055wjhhz" autocomplete="current-password">
            </label>
            <label>
                Gateway SN
                <input type="text" name="gateway" required value="9N9CN8400164WH" autocomplete="off">
            </label>
            <label>
                传输
                <select name="protocol">
                    <option value="ws">WS (ws://)</option>
                    <option value="wss">WSS (wss://)</option>
                </select>
            </label>
            <div class="actions">
                <button type="button" id="connect-btn">连接</button>
                <button type="button" class="secondary" id="disconnect-btn" disabled>断开</button>
                <div class="status" id="connection-status">
                    <span class="status-dot" id="status-dot"></span>
                    <span id="status-text">未连接</span>
                </div>
            </div>
        </form>

        <div class="joysticks">
            <section class="stick-card">
                <h2>左杆：油门 / 偏航</h2>
                <div id="left-stick" class="stick-area"></div>
                <div class="stick-channel">
                    <span>throttle <strong data-channel="throttle">1024</strong></span>
                    <span>yaw <strong data-channel="yaw">1024</strong></span>
                </div>
            </section>
            <section class="stick-card">
                <h2>右杆：横滚 / 俯仰</h2>
                <div id="right-stick" class="stick-area"></div>
                <div class="stick-channel">
                    <span>roll <strong data-channel="roll">1024</strong></span>
                    <span>pitch <strong data-channel="pitch">1024</strong></span>
                </div>
            </section>
        </div>

        <section class="payload">
            <div>Topic: <code id="topic-preview">thing/product/9N9CN8400164WH/drc/down</code></div>
            <div style="margin-top:0.5rem;">最近发送：</div>
            <pre id="payload-preview">{}</pre>
        </section>
        <p class="warning">
            提示：页面会以 10Hz 向飞行器发送 stick_control 指令（无回包）。请在连接前确认 DRC 链路已建立，
            且 MQTT Broker 支持 WebSocket 连接。
        </p>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/mqtt@5.3.3/dist/mqtt.min.js" crossorigin="anonymous"></script>
    <script>
        const CENTER_VALUE = 1024;
        const RANGE = 660;
        const MIN_VALUE = CENTER_VALUE - RANGE;
        const MAX_VALUE = CENTER_VALUE + RANGE;
        const DEAD_ZONE = 0.05;
        const PUBLISH_INTERVAL_MS = 100; // 10Hz

        const state = {
            roll: CENTER_VALUE,
            pitch: CENTER_VALUE,
            throttle: CENTER_VALUE,
            yaw: CENTER_VALUE,
        };

        let client = null;
        let publishTimer = null;
        const stickControllers = {};
        let currentGateway = document.querySelector('input[name="gateway"]').value.trim();

        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const topicPreview = document.getElementById('topic-preview');
        const payloadPreview = document.getElementById('payload-preview');
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const form = document.getElementById('connection-form');

        function setStatus(message, mode = 'idle') {
            statusText.textContent = message;
            statusDot.classList.remove('connected', 'error');
            if (mode === 'connected') {
                statusDot.classList.add('connected');
            } else if (mode === 'error') {
                statusDot.classList.add('error');
            }
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function normalizedToStickValue(normalized) {
            if (Math.abs(normalized) < DEAD_ZONE) {
                normalized = 0;
            }
            const scaled = Math.round(CENTER_VALUE + normalized * RANGE);
            return clamp(scaled, MIN_VALUE, MAX_VALUE);
        }

        function normalizedFromState(channel) {
            return clamp((state[channel] - CENTER_VALUE) / RANGE, -1, 1);
        }

        function updateChannelDisplay() {
            for (const key of Object.keys(state)) {
                const target = document.querySelector(`[data-channel="${key}"]`);
                if (target) {
                    target.textContent = state[key];
                }
            }
            for (const controller of Object.values(stickControllers)) {
                if (controller) {
                    controller.sync();
                }
            }
        }

        function updateTopicPreview() {
            const nextTopic = `thing/product/${currentGateway}/drc/down`;
            topicPreview.textContent = nextTopic;
        }

        function computeNormalizedFromEvent(event, zone) {
            const rect = zone.getBoundingClientRect();
            const xRatio = clamp((event.clientX - rect.left) / rect.width, 0, 1);
            const yRatio = clamp((event.clientY - rect.top) / rect.height, 0, 1);
            return {
                x: xRatio * 2 - 1,
                y: (1 - yRatio) * 2 - 1,
            };
        }

        function initStick(zoneId, mapping) {
            const zone = document.getElementById(zoneId);
            const indicator = document.createElement('div');
            indicator.className = 'stick-indicator';
            zone.appendChild(indicator);

            const stateRef = {
                active: false,
                pointerId: null,
            };

            function setIndicator(normX, normY) {
                const width = zone.clientWidth || 1;
                const height = zone.clientHeight || 1;
                const indicatorWidth = indicator.offsetWidth || 0;
                const indicatorHeight = indicator.offsetHeight || 0;
                const maxOffsetX = Math.max((width - indicatorWidth) / 2, 0);
                const maxOffsetY = Math.max((height - indicatorHeight) / 2, 0);
                const offsetX = clamp(normX, -1, 1) * maxOffsetX;
                const offsetY = clamp(-normY, -1, 1) * maxOffsetY;
                indicator.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px)`;
            }

            function applyNormalized(normX, normY) {
                state[mapping.horizontal] = normalizedToStickValue(normX);
                state[mapping.vertical] = normalizedToStickValue(normY);
                updateChannelDisplay();
            }

            function releasePointer() {
                if (!stateRef.active) {
                    return;
                }
                const capturedId = stateRef.pointerId;
                stateRef.active = false;
                stateRef.pointerId = null;
                try {
                    if (capturedId != null) {
                        zone.releasePointerCapture(capturedId);
                    }
                } catch (_error) {
                    // ignore
                }
                setIndicator(0, 0);
                applyNormalized(0, 0);
            }

            zone.addEventListener('pointerdown', (event) => {
                event.preventDefault();
                zone.setPointerCapture(event.pointerId);
                stateRef.active = true;
                stateRef.pointerId = event.pointerId;
                const { x, y } = computeNormalizedFromEvent(event, zone);
                setIndicator(x, y);
                applyNormalized(x, y);
            });

            zone.addEventListener('pointermove', (event) => {
                if (!stateRef.active || event.pointerId !== stateRef.pointerId) {
                    return;
                }
                event.preventDefault();
                const { x, y } = computeNormalizedFromEvent(event, zone);
                setIndicator(x, y);
                applyNormalized(x, y);
            });

            zone.addEventListener('pointerup', (event) => {
                if (event.pointerId === stateRef.pointerId) {
                    event.preventDefault();
                    releasePointer();
                }
            });

            zone.addEventListener('pointercancel', releasePointer);
            zone.addEventListener('pointerleave', (event) => {
                if (stateRef.active && event.pointerId === stateRef.pointerId) {
                    releasePointer();
                }
            });

            const controller = {
                sync() {
                    const normX = normalizedFromState(mapping.horizontal);
                    const normY = normalizedFromState(mapping.vertical);
                    setIndicator(normX, normY);
                },
            };

            stickControllers[zoneId] = controller;
            controller.sync();
        }

        initStick('left-stick', { horizontal: 'yaw', vertical: 'throttle' });
        initStick('right-stick', { horizontal: 'roll', vertical: 'pitch' });

        window.addEventListener('resize', () => {
            for (const controller of Object.values(stickControllers)) {
                if (controller) {
                    controller.sync();
                }
            }
        });

        function readConfig() {
            const formData = new FormData(form);
            const protocol = formData.get('protocol') || 'ws';
            const host = (formData.get('host') || '').trim();
            const port = (formData.get('port') || '').trim();
            const path = (formData.get('path') || '').trim() || '/mqtt';
            const username = (formData.get('username') || '').trim();
            const password = formData.get('password') || '';
            const gateway = (formData.get('gateway') || '').trim();
            let clientId = (formData.get('clientId') || '').trim();
            if (!clientId) {
                clientId = `drc-joystick-${Math.random().toString(16).slice(2, 10)}`;
                form.querySelector('input[name="clientId"]').value = clientId;
            }
            return {
                url: `${protocol}://${host}:${port}${path}`,
                clientId,
                username,
                password,
                gateway,
                protocol,
            };
        }

        function setButtonsOnConnect(connected) {
            connectBtn.disabled = connected;
            disconnectBtn.disabled = !connected;
            form.querySelectorAll('input, select').forEach((input) => {
                input.disabled = connected && input.name !== 'gateway';
            });
        }

        function startPublishing() {
            if (publishTimer) {
                clearInterval(publishTimer);
            }
            publishTimer = setInterval(sendStickControl, PUBLISH_INTERVAL_MS);
        }

        function stopPublishing() {
            if (publishTimer) {
                clearInterval(publishTimer);
                publishTimer = null;
            }
        }

        function sendStickControl() {
            if (!client || !client.connected) {
                return;
            }
            const topic = `thing/product/${currentGateway}/drc/down`;
            const payload = {
                seq: Date.now(),
                method: 'stick_control',
                data: {
                    roll: state.roll,
                    pitch: state.pitch,
                    throttle: state.throttle,
                    yaw: state.yaw,
                },
            };
            const encoded = JSON.stringify(payload);
            client.publish(topic, encoded, { qos: 0 }, (error) => {
                if (error) {
                    setStatus(`发送失败：${error.message || error}`, 'error');
                } else {
                    payloadPreview.textContent = encoded;
                }
            });
        }

        function connect() {
            try {
                const { url, clientId, username, password, gateway } = readConfig();
                if (!gateway) {
                    setStatus('请填写 Gateway SN', 'error');
                    return;
                }
                currentGateway = gateway;
                updateTopicPreview();
                setStatus('连接中…');
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                stopPublishing();

                client = mqtt.connect(url, {
                    clientId,
                    username: username || undefined,
                    password: password || undefined,
                    keepalive: 30,
                    reconnectPeriod: 2000,
                    clean: true,
                });

                client.on('connect', () => {
                    setStatus('已连接', 'connected');
                    setButtonsOnConnect(true);
                    startPublishing();
                });

                client.on('reconnect', () => {
                    setStatus('重连中…');
                });

                client.on('close', () => {
                    setStatus('连接已关闭');
                    setButtonsOnConnect(false);
                    stopPublishing();
                });

                client.on('error', (err) => {
                    setStatus(`错误：${err && err.message ? err.message : '未知错误'}`, 'error');
                    setButtonsOnConnect(false);
                    connectBtn.disabled = false;
                    stopPublishing();
                });
            } catch (error) {
                setStatus(`配置错误：${error.message}`, 'error');
            }
        }

        function disconnect() {
            if (client) {
                try {
                    client.end(true);
                } catch (error) {
                    console.warn('MQTT end failed', error);
                }
            }
            client = null;
            stopPublishing();
            setButtonsOnConnect(false);
            setStatus('已断开');
            connectBtn.disabled = false;
        }

        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);

        form.addEventListener('change', (event) => {
            if (event.target.name === 'gateway') {
                currentGateway = event.target.value.trim();
                updateTopicPreview();
            }
        });

        document.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });
        document.addEventListener('selectstart', (event) => {
            event.preventDefault();
        });

        updateTopicPreview();
        updateChannelDisplay();
    </script>
</body>
</html>
