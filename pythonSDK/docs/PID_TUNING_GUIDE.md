# PID控制器调参完全指南

## 📚 目录

1. [PID原理](#pid原理)
2. [三个参数的作用](#三个参数的作用)
3. [调参速查表](#调参速查表)
4. [常见现象分析](#常见现象分析)
5. [系统化调参法](#系统化调参法)
6. [实战技巧](#实战技巧)
7. [数学推导](#数学推导)

---

## 🎓 PID原理

### 什么是PID？

PID（比例-积分-微分）控制器是一种反馈控制系统，通过计算**误差**（目标值 - 当前值）来产生控制输出。

### 基本公式

```
u(t) = Kp·e(t) + Ki·∫e(τ)dτ + Kd·de(t)/dt
```

其中：

- `e(t)` = 误差（error）= 目标位置 - 当前位置
- `u(t)` = 控制输出（杆量偏移）
- `Kp` = 比例增益（Proportional gain）
- `Ki` = 积分增益（Integral gain）
- `Kd` = 微分增益（Derivative gain）

### 离散化实现（代码中的形式）

```python
# 时间间隔
dt = current_time - last_time

# P项：正比于当前误差
p_term = Kp * error

# I项：累积历史误差
integral += error * dt
i_term = Ki * integral

# D项：误差变化率
derivative = (error - last_error) / dt
d_term = Kd * derivative

# 总输出
output = p_term + i_term + d_term
```

---

## ⚙️ 三个参数的作用

### 1. Kp（比例项）- "主驱动力"

**物理意义**：

- 误差越大，控制力越强
- 就像弹簧：拉得越远，拉力越大

**数学表达**：

```
u_p(t) = Kp · e(t)
```

**特点**：

- ✅ 提供主要控制力
- ✅ 响应速度快
- ❌ 无法消除静差（最后会差一点点）
- ❌ 过大会振荡

**比喻**：
想象你开车到目的地，距离越远，油门踩得越深。但问题是，你只看距离不看速度，容易冲过头。

---

### 2. Ki（积分项）- "纠偏器"

**物理意义**：

- 累积历史误差
- 消除长期存在的小误差（静差）
- 就像"记仇"：过去的误差都要算账

**数学表达**：

```
u_i(t) = Ki · ∫₀ᵗ e(τ) dτ
```

**特点**：

- ✅ 消除静差（最终能到达目标）
- ✅ 抵抗外部干扰（如风）
- ❌ 过大会超调
- ❌ 过大会振荡

**比喻**：
如果你总是差一点点到不了目的地，积分项会说"这次多给点油！"直到完全到达。

---

### 3. Kd（微分项）- "刹车"

**物理意义**：

- 预测未来趋势
- 提前减速，避免冲过头
- 就像"阻尼器"：速度越快，阻力越大

**数学表达**：

```
u_d(t) = Kd · de(t)/dt
```

**特点**：

- ✅ 减少超调
- ✅ 提高稳定性
- ✅ 抑制振荡
- ❌ 放大噪声
- ❌ 过大会响应变慢

**比喻**：
当你快速接近目的地时，Kd会说"慢点！要撞了！"提前踩刹车。

---

## 📊 调参速查表


| 现象             | 可能原因         | 物理解释                   | 数学原因                   | 调整方法                               | 示例                 |
| ---------------- | ---------------- | -------------------------- | -------------------------- | -------------------------------------- | -------------------- |
| **过冲严重**     | Kp太大 或 Kd太小 | 油门太猛，刹车不足         | P项贡献过大，D项阻尼不足   | ① 减小Kp (×0.7)<br>② 增大Kd (×1.5) | 150→100,<br>80→120 |
| **响应慢**       | Kp太小           | 油门太轻，动力不足         | P项贡献不足，误差收敛慢    | 增大Kp (×1.5)                         | 100→150             |
| **震荡不停**     | Kp太大 或 Ki太大 | 油门过猛且记忆太强         | 系统增益过高，相位裕度不足 | ① 减小Kp (×0.6)<br>② 减小Ki (×0.5) | 150→90<br>20→10    |
| **到不了目标**   | Ki太小           | 缺少"坚持"，遇阻就放弃     | 积分项不足以消除静差       | 增大Ki (×2)                           | 10→20               |
| **抖动明显**     | Kd太大           | 刹车过敏，对小波动过度反应 | 微分项放大高频噪声         | 减小Kd (×0.7)                         | 120→80              |
| **漂移**         | Ki太小           | 对持续偏差不敏感           | 积分项累积速度不足         | 增大Ki (×1.5)                         | 20→30               |
| **冲过后来回摆** | Kd太小           | 刹车太弱，停不住           | 阻尼不足，系统欠阻尼       | 增大Kd (×2)                           | 50→100              |

---

## 🔬 常见现象分析

### 现象1：过冲（Overshoot）

#### 📸 现象描述

无人机飞过目标点，然后再往回飞，可能会来回摆动几次才稳定。

#### 🔍 根本原因

**物理层面**：

```
惯性 + 控制力过强 → 来不及刹车 → 冲过头
```

**数学层面**：

```
当 e(t) 接近 0 时：
- P项 = Kp · e(t) ≈ 0（控制力消失）
- D项 = Kd · de/dt < 0（但如果Kd太小，阻尼不足）

如果 Kp 太大：
→ 在 e(t) 还比较大时，u(t) 已经很大
→ 速度 v(t) 累积过快
→ 当 e(t) = 0 时，v(t) ≠ 0
→ 冲过目标点
```

**传递函数分析**：

```
系统的阻尼比 ζ ∝ Kd / (Kp · m)
其中 m 是无人机质量

Kp 太大 → ζ 减小 → 欠阻尼 → 振荡
Kd 太小 → ζ 减小 → 欠阻尼 → 振荡
```

#### 💊 解决方案

**方案1：降低Kp**

```python
# 原因：减少控制力，给系统留反应时间
KP = 100.0  # 从 150 降到 100（×0.67）
```

**方案2：增大Kd**

```python
# 原因：增强阻尼，提前减速
KD = 120.0  # 从 80 增到 120（×1.5）
```

**物理直觉**：

- 降Kp = 开车时别踩太猛油门
- 增Kd = 看到红灯提前踩刹车

---

### 现象2：响应慢（Slow Response）

#### 📸 现象描述

无人机飞得很慢，需要很长时间才能到达目标点。

#### 🔍 根本原因

**物理层面**：

```
控制力太小 → 加速度小 → 速度慢 → 到达时间长
```

**数学层面**：

```
u(t) = Kp · e(t) + ...

如果 Kp 太小：
→ u(t) 很小
→ 加速度 a = F/m = u/m 很小
→ 速度增长慢
→ 位置变化慢
```

**时域分析**：

```
系统响应时间 τ ∝ 1/Kp

Kp 太小 → τ 增大 → 响应变慢
```

#### 💊 解决方案

```python
# 增大Kp，提供更强的控制力
KP = 150.0  # 从 100 增到 150（×1.5）
```

---

### 现象3：震荡不停（Sustained Oscillation）

#### 📸 现象描述

无人机在目标点附近来回摆动，永远停不下来。

#### 🔍 根本原因

**物理层面**：

```
控制力过强 + 积分"记忆"过强 → 系统不稳定 → 持续振荡
```

**数学层面**：

**情况1：Kp 太大**

```
u(t) = Kp · e(t)

当 e(t) > 0 时：u(t) 很大 → 快速接近
当 e(t) ≈ 0 时：由于惯性，冲过头
当 e(t) < 0 时：u(t) 反向很大 → 又快速反向
→ 无限循环
```

**情况2：Ki 太大**

```
integral += e(t) · dt
u_i(t) = Ki · integral

即使 e(t) 已经很小，但历史误差累积 integral 很大
→ u_i(t) 仍然很大
→ 持续施加过大的力
→ 冲过头后，integral 变负，又往回推
→ 无限循环
```

**稳定性分析**（闭环传递函数）：

```
系统特征方程：s² + (Kd·s + Kp)/m·s + Ki/m = 0

Routh-Hurwitz 稳定性判据：
需要满足：Kd·Kp > Ki·m

如果 Kp 或 Ki 过大，系统极点进入右半平面 → 不稳定 → 振荡
```

#### 💊 解决方案

```python
# 方案1：减小Kp（推荐先试这个）
KP = 90.0  # 从 150 降到 90（×0.6）

# 方案2：减小Ki
KI = 10.0  # 从 20 降到 10（×0.5）

# 方案3：增大Kd（增加阻尼）
KD = 100.0  # 从 80 增到 100（×1.25）
```

---

### 现象4：到不了目标点（Steady-State Error）

#### 📸 现象描述

无人机飞到目标点附近就停了，总是差10-20cm。

#### 🔍 根本原因

**物理层面**：

```
存在外部干扰（如风、重力不平衡）
控制力小于阻力 → 无法完全消除误差
```

**数学层面**：

**纯P控制的问题**：

```
假设存在稳态误差 e_ss ≠ 0

此时速度 v = 0，误差不再变化：
u_ss = Kp · e_ss

系统受力平衡：
控制力 = 阻力
u_ss = f_drag

→ Kp · e_ss = f_drag
→ e_ss = f_drag / Kp

结论：只要有阻力，就必然存在静差！
```

**积分项的作用**：

```
integral += e(t) · dt

即使 e(t) 很小，积分项会不断累积：
integral = ∫e(τ)dτ → 越来越大

→ u_i = Ki · integral → 越来越大
→ 直到 u_i 足以克服阻力
→ e(t) → 0
```

#### 💊 解决方案

```python
# 增大Ki，让积分项有足够力量消除静差
KI = 20.0  # 从 10 增到 20（×2）
```

---

### 现象5：抖动明显（High-Frequency Oscillation）

#### 📸 现象描述

无人机到达目标点后，出现高频小幅度的抖动。

#### 🔍 根本原因

**物理层面**：

```
传感器噪声 + 过敏的微分项 → 对小波动过度反应
```

**数学层面**：

**微分项的特性**：

```
u_d(t) = Kd · de/dt

微分运算会放大高频信号：
如果 e(t) 包含噪声 n(t)：
e(t) = e_real(t) + n(t)

则：
de/dt = de_real/dt + dn/dt

噪声通常是高频的：
dn/dt >> de_real/dt

→ 微分项主要响应噪声
→ 输出 u(t) 抖动
```

**频域分析**：

```
微分器的传递函数：G_d(s) = Kd · s

幅频特性：|G_d(jω)| = Kd · ω
→ 频率越高，增益越大
→ 高频噪声被放大 Kd 倍
```

#### 💊 解决方案

```python
# 减小Kd，降低对高频噪声的敏感度
KD = 60.0  # 从 80 降到 60（×0.75）

# 或者在代码中加入低通滤波器
# filtered_error = 0.9 * filtered_error + 0.1 * current_error
```

---

### 现象6：漂移（Drift）

#### 📸 现象描述

无人机到达目标点后，缓慢地往一个方向飘移。

#### 🔍 根本原因

**物理层面**：

```
持续存在的外部力（如恒定的风）
积分项累积速度不够快，无法及时纠正
```

**数学层面**：

**外部干扰模型**：

```
假设存在恒定外力 F_ext（如风）

系统动力学：
m·a = u(t) - F_ext

稳态时：
u_ss = F_ext
```

**积分项响应速度**：

```
integral = ∫e(τ)dτ
u_i = Ki · integral

如果 Ki 太小：
→ 即使 integral 在增长
→ u_i 增长速度慢
→ 来不及抵消外力
→ 系统漂移
```

#### 💊 解决方案

```python
# 增大Ki，加快积分累积速度
KI = 30.0  # 从 20 增到 30（×1.5）
```

---

### 现象7：冲过后来回摆（Underdamped Oscillation）

#### 📸 现象描述

无人机冲过目标点，然后往回飞，再冲过，来回摆动几次才稳定（但最终能稳定）。

#### 🔍 根本原因

**物理层面**：

```
阻尼不足 → 能量耗散慢 → 多次振荡才能消耗完动能
```

**数学层面**：

**二阶系统模型**：

```
m·d²x/dt² + c·dx/dt + k·x = 0

其中：
- m：质量（无人机惯性）
- c：阻尼系数（∝ Kd）
- k：弹性系数（∝ Kp）

阻尼比：
ζ = c / (2√(mk)) ∝ Kd / √(m·Kp)

当 0 < ζ < 1（欠阻尼）：
→ 系统振荡
→ 振荡次数 ∝ 1/ζ
```

**解的形式**：

```
x(t) = A·e^(-ζω_n·t)·sin(ω_d·t + φ)

其中：
- ω_n = √(Kp/m)：自然频率
- ω_d = ω_n√(1-ζ²)：阻尼振荡频率
- 振幅衰减 ∝ e^(-ζω_n·t)

如果 Kd 太小：
→ ζ 太小
→ 衰减慢
→ 振荡持续时间长
```

#### 💊 解决方案

```python
# 增大Kd，增加阻尼，加快能量耗散
KD = 100.0  # 从 50 增到 100（×2）
```

**物理直觉**：
想象一个弹簧振子（如秋千）：

- 无阻尼（Kd=0）：永远摆动
- 小阻尼（Kd小）：摆很多次才停
- 临界阻尼（Kd刚好）：最快停下，不摆动
- 过阻尼（Kd大）：慢慢停下，不摆动

---

## 🎛️ 系统化调参法

### 方法1：Ziegler-Nichols 法（经典）

#### 步骤

**阶段1：找临界点**

```python
# 设置
KP = 50    # 从小开始
KI = 0
KD = 0

# 逐步增大 Kp，直到系统开始持续振荡
# 记录：
# - K_u：临界增益（振荡开始时的 Kp）
# - T_u：振荡周期（秒）
```

**阶段2：计算参数**

```python
# 经典 PID（最常用）
KP = 0.6 * K_u
KI = 1.2 * K_u / T_u
KD = 0.075 * K_u * T_u

# 或者 PI（更保守）
KP = 0.45 * K_u
KI = 0.54 * K_u / T_u
KD = 0

# 或者 PD（无超调）
KP = 0.8 * K_u
KI = 0
KD = 0.1 * K_u * T_u
```

#### 示例

假设测得：

- `K_u = 250`（Kp=250时开始振荡）
- `T_u = 1.2`秒

则：

```python
KP = 0.6 * 250 = 150
KI = 1.2 * 250 / 1.2 = 250
KD = 0.075 * 250 * 1.2 = 22.5
```

---

### 方法2：逐步逼近法（推荐新手）

#### 步骤1：调Kp（找主动力）

```python
# 初始值
KP = 50
KI = 0
KD = 0

# 测试流程
while True:
    测试飞行
    if 响应太慢:
        KP *= 1.5  # 增大50%
    elif 开始震荡:
        KP *= 0.6  # 减小40%
        break
    else:
        break

# 最终选择：震荡前的最大值 × 0.6
```

**判断标准**：

- 响应太慢：到达时间 > 5秒
- 开始震荡：来回摆动 > 2次

#### 步骤2：调Ki（消除静差）

```python
# 使用步骤1得到的Kp
KI = 5  # 从小开始
KD = 0

# 测试流程
while True:
    测试飞行
    if 到不了目标点（误差>5cm）:
        KI *= 1.5
    elif 超调增大:
        KI *= 0.8
        break
    else:
        break
```

#### 步骤3：调Kd（减少超调）

```python
# 使用步骤1和2得到的Kp, Ki
KD = 20  # 从小开始

# 测试流程
while True:
    测试飞行
    if 超调明显（冲过>10cm）:
        KD *= 1.5
    elif 响应变慢 or 抖动:
        KD *= 0.7
        break
    else:
        break
```

---

### 方法3：口诀记忆法（快速调整）

```
参数增大，现象看：

【Kp增大】
 ✓ 响应变快
 ✓ 控制力强
 ✗ 容易振荡
 ✗ 容易超调

【Ki增大】
 ✓ 消除静差
 ✓ 抗扰能力强
 ✗ 增加超调
 ✗ 容易振荡

【Kd增大】
 ✓ 减少超调
 ✓ 提高稳定性
 ✓ 抑制振荡
 ✗ 响应变慢
 ✗ 放大噪声
```

**口诀**：

```
P 负责快，
I 负责准，
D 负责稳。

过冲看 D，D 不够加；
震荡看 P，P 太大减；
差距看 I，I 太小增。
```

---

## 💡 实战技巧

### 技巧1：安全第一原则

```python
# 第一次测试，使用保守参数
KP = 80   # 偏小
KI = 5    # 偏小
KD = 50   # 适中
MAX_STICK_OUTPUT = 200  # 限制为小杆量

# 确认安全后，再逐步增大
```

### 技巧2：单变量法

**永远一次只调一个参数！**

```python
# ✅ 正确
KP = 150  # 只改这个
KI = 20   # 不变
KD = 80   # 不变

# ❌ 错误
KP = 200  # 改了
KI = 30   # 也改了 → 不知道是哪个导致的问题
KD = 100  # 还改了
```

### 技巧3：参数变化倍率

```python
# 推荐的变化步长
增大：× 1.2 ~ 1.5
减小：× 0.6 ~ 0.8

# 避免
增大：× 2.0  # 太激进
减小：× 0.5  # 太激进
```

### 技巧4：记录参数历史

```markdown
| 测试 | Kp | Ki | Kd | 现象 | 备注 |
|------|----|----|----|----|------|
| 1 | 100 | 10 | 50 | 响应慢 | 到达时间7秒 |
| 2 | 150 | 10 | 50 | 过冲20cm | 冲过后回来 |
| 3 | 150 | 10 | 80 | 过冲10cm | 好转 |
| 4 | 150 | 15 | 80 | 轻微过冲 | ✓ 可用 |
```

### 技巧5：环境一致性

确保每次测试条件相同：

- ✅ 同一个起点
- ✅ 同一个目标点
- ✅ 同样的初始速度（悬停状态）
- ✅ 相似的风速（室内）

### 技巧6：渐进式目标

```python
# 阶段1：短距离（50cm）
TARGET_X = 0.5
TARGET_Y = 0.0

# 阶段2：中距离（1m）
TARGET_X = 1.0
TARGET_Y = 0.0

# 阶段3：对角线（1.4m）
TARGET_X = 1.0
TARGET_Y = 1.0
```

---

## 📐 数学推导

### 1. 为什么P控制有静差？

**系统模型**：

```
一阶系统：τ·dy/dt + y = u

其中：
- y：输出（位置）
- u：输入（控制力）
- τ：时间常数
```

**纯P控制**：

```
u(t) = Kp · (r - y)

其中 r 是目标值
```

**稳态分析**（dy/dt = 0）：

```
y_ss = u_ss
u_ss = Kp · (r - y_ss)

→ y_ss = Kp · r - Kp · y_ss
→ y_ss · (1 + Kp) = Kp · r
→ y_ss = Kp/(1+Kp) · r

误差：
e_ss = r - y_ss = r/(1+Kp)
```

**结论**：

```
只有当 Kp → ∞ 时，e_ss → 0

但 Kp 太大会导致不稳定，因此必然存在静差！
```

---

### 2. 积分项如何消除静差？

**PI控制**：

```
u(t) = Kp · e(t) + Ki · ∫e(τ)dτ
```

**稳态分析**（e_ss 为常数）：

```
假设存在稳态误差 e_ss ≠ 0

则积分项会无限增长：
∫e(τ)dτ → ∞

→ u(t) → ∞

这违反了物理约束（输出有限），因此必然 e_ss = 0
```

**更严格的证明**（终值定理）：

```
拉普拉斯域：
E(s) = R(s) - Y(s)

闭环传递函数：
Y(s)/R(s) = G(s)/(1 + G(s))

其中 G(s) = (Kp·s + Ki)/s（PI控制器）

稳态误差：
e_ss = lim(s→0) s·E(s)
     = lim(s→0) s · R(s) · [1 - G(s)/(1+G(s))]
     = lim(s→0) s · R(s) · [1/(1+G(s))]

对于阶跃输入 R(s) = 1/s：
e_ss = lim(s→0) [1/(1 + (Kp·s+Ki)/s)]
     = lim(s→0) [s/(s + Kp·s + Ki)]
     = 0/Ki = 0

结论：积分项使 e_ss = 0
```

---

### 3. 微分项如何减少超调？

**二阶系统（典型）**：

```
m·d²y/dt² + c·dy/dt + k·y = u(t)
```

**PD控制**：

```
u(t) = Kp·(r - y) - Kd·dy/dt

注意负号：dy/dt 是输出的微分，不是误差的微分
```

**代入系统方程**：

```
m·d²y/dt² + c·dy/dt + k·y = Kp·r - Kp·y - Kd·dy/dt

重新排列：
m·d²y/dt² + (c + Kd)·dy/dt + (k + Kp)·y = Kp·r
```

**等效阻尼**：

```
c_eff = c + Kd

→ 增大 Kd 相当于增大系统阻尼
→ 阻尼比 ζ 增大
→ 超调量 M_p 减小
```

**超调量公式**：

```
M_p = exp(-πζ/√(1-ζ²))

ζ 增大 → M_p 减小 → 超调减少
```

---

### 4. 稳定性分析（Routh-Hurwitz）

**PID控制的闭环系统**：

```
特征方程：
s³ + a₂s² + a₁s + a₀ = 0

其中：
a₂ = (c + Kd)/m
a₁ = (k + Kp)/m
a₀ = Ki/m
```

**Routh表**：

```
s³ |  1       a₁
s² |  a₂      a₀
s¹ |  b₁      0
s⁰ |  a₀      0

其中：b₁ = (a₂·a₁ - a₀)/a₂
```

**稳定性条件**：

```
所有系数 > 0：a₂ > 0, a₁ > 0, a₀ > 0
且：b₁ > 0

→ a₂·a₁ > a₀
→ (c+Kd)·(k+Kp) > Ki·m

简化（忽略原有阻尼c和刚度k）：
Kd·Kp > Ki·m

结论：Kp 或 Ki 太大，或 Kd 太小，系统不稳定！
```

---

### 5. 频域分析（Bode图）

**开环传递函数**：

```
G_ol(s) = (Kd·s² + Kp·s + Ki) / (s·m·s²)
        = (Kd·s² + Kp·s + Ki) / (m·s³)
```

**增益裕度（GM）和相位裕度（PM）**：

**Kp 增大**：

```
→ 低频增益增大
→ 穿越频率 ω_c 增大
→ 相位裕度 PM 减小
→ 稳定性降低
→ 容易振荡
```

**Kd 增大**：

```
→ 高频相位提前（lead）
→ 相位裕度 PM 增大
→ 稳定性提高
→ 抑制振荡
```

**Ki 增大**：

```
→ 极低频增益增大
→ 改善稳态精度
→ 但相位滞后（lag）
→ 相位裕度 PM 减小
→ 可能降低稳定性
```

---

## 🎯 推荐参数组合

### 场景1：快速响应（竞速场景）

```python
KP = 200.0  # 高增益，快速响应
KI = 30.0   # 较大，快速消除误差
KD = 150.0  # 很大，抑制高速振荡
MAX_STICK_OUTPUT = 500  # 允许大杆量

# 特点：快速但可能有小幅震荡
# 适用：熟练操作员，竞速比赛
```

### 场景2：平稳控制（摄影场景）

```python
KP = 80.0   # 低增益，平稳
KI = 10.0   # 较小，避免超调
KD = 100.0  # 大阻尼，平滑过渡
MAX_STICK_OUTPUT = 250  # 限制杆量

# 特点：慢但非常稳定，无超调
# 适用：航拍、精确悬停
```

### 场景3：平衡折中（推荐）

```python
KP = 150.0  # 适中
KI = 20.0   # 适中
KD = 80.0   # 适中
MAX_STICK_OUTPUT = 330  # 半杆量

# 特点：性能均衡
# 适用：日常使用、初学者
```

### 场景4：减少过冲（当前问题）

```python
KP = 100.0  # 降低（×0.67）
KI = 15.0   # 略降（×0.75）
KD = 120.0  # 增大（×1.5）
MAX_STICK_OUTPUT = 330

# 特点：几乎无超调，稳定第一
# 适用：解决当前过冲问题
```

---

## 📚 参考资料

### 经典教材

1. "Feedback Control of Dynamic Systems" - Franklin, Powell, Emami-Naeini
2. "Modern Control Engineering" - Katsuhiko Ogata
3. "PID Controllers: Theory, Design, and Tuning" - Åström & Hägglund

### 在线资源

- [Wikipedia: PID Controller](https://en.wikipedia.org/wiki/PID_controller)
- [Control Tutorials: PID Tutorial](https://ctms.engin.umich.edu/CTMS/index.php?example=Introduction&section=ControlPID)

### 调参工具

- MATLAB Control System Toolbox
- Python Control Systems Library
- PID Tuner Apps

---

## ✅ 快速检查清单

在调整参数前，确认：

- [ ]  系统已经稳定悬停
- [ ]  VRPN数据正常（无跳变）
- [ ]  MQTT连接正常（心跳稳定）
- [ ]  环境安全（空旷、无人）
- [ ]  遥控器开启（随时接管）

调参过程中：

- [ ]  一次只改一个参数
- [ ]  每次测试前悬停在同一位置
- [ ]  记录每次测试的现象
- [ ]  参数变化倍率合理（1.2~1.5倍）
- [ ]  出现异常立即停止

---

## 🎓 总结

### 核心原则

1. **P是主力，I是辅助，D是刹车**
2. **一次只调一个参数**
3. **从小到大，逐步增加**
4. **安全第一，保守起步**
5. **记录数据，对比分析**

### 调参口诀

```
过冲减P增D，
震荡减P减I，
差距增I，
抖动减D。
```

### 万能救命公式

**遇到任何问题都不知道怎么办？**

```python
# 重置为极保守参数
KP = 50.0
KI = 5.0
KD = 50.0
MAX_STICK_OUTPUT = 200

# 然后按步骤重新调
```

---

**祝调参顺利！🚁**
